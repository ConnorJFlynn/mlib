function [modes,usedBits]=extract_qc_bits(dmodebits);
%modes=extract_qc_bits(modebits);
% DO NOT EDIT THIS FILE.  It is automatically created.
% Edit mask_qc_bits.txt and then run make

modes = struct('struct_version','$Revision: 1.1 $','translate_version','$Revision: 1.1 $');
if nargin>0
usedBits = uint32(0);
if isstruct(dmodebits)
	modes=dmodebits;
	return;
end;
modebits=uint32(dmodebits);
modebits(dmodebits<0)=uint32(intmax('uint32'));

modes = setfield(modes,'complete_mask',bitget(modebits,1)~=0);
usedBits = bitset(usedBits,1);
modes = setfield(modes,'lidar_ok_mask',bitget(modebits,2)~=0);
usedBits = bitset(usedBits,2);
modes = setfield(modes,'lock_quality_mask',bitget(modebits,3)~=0);
usedBits = bitset(usedBits,3);
modes = setfield(modes,'seed_quality_mask',bitget(modebits,4)~=0);
usedBits = bitset(usedBits,4);
modes = setfield(modes,'mol_count_snr_mask',bitget(modebits,5)~=0);
usedBits = bitset(usedBits,5);
modes = setfield(modes,'backscat_snr_mask',bitget(modebits,6)~=0);
usedBits = bitset(usedBits,6);
modes = setfield(modes,'mol_lost_mask',bitget(modebits,7)~=0);
usedBits = bitset(usedBits,7);
modes = setfield(modes,'min_backscat_mask',bitget(modebits,8)~=0);
usedBits = bitset(usedBits,8);
modes = setfield(modes,'radar_backscat_mask',bitget(modebits,9)~=0);
usedBits = bitset(usedBits,9);
modes = setfield(modes,'radar_ok_mask',bitget(modebits,10)~=0);
usedBits = bitset(usedBits,10);
modes = setfield(modes,'aeri_ok_mask',bitget(modebits,11)~=0);
usedBits = bitset(usedBits,11);
modes = setfield(modes,'aeri_qc_mask',bitget(modebits,12)~=0);
usedBits = bitset(usedBits,12);
modes = setfield(modes,'lidar_mask',modes.lidar_ok_mask&modes.lock_quality_mask&modes.seed_quality_mask&modes.mol_count_snr_mask&modes.backscat_snr_mask&modes.mol_lost_mask&modes.min_backscat_mask);
modes = setfield(modes,'od_mask',modes.lidar_ok_mask&modes.lock_quality_mask&modes.seed_quality_mask);
modes = setfield(modes,'radar_mask',modes.radar_backscat_mask&modes.radar_ok_mask);
modes = setfield(modes,'backscat_mask',modes.lidar_ok_mask&modes.radar_ok_mask);
modes = setfield(modes,'beta_a_mask',modes.lock_quality_mask&modes.seed_quality_mask&modes.mol_count_snr_mask&modes.backscat_snr_mask&modes.mol_lost_mask&modes.min_backscat_mask);
modes = setfield(modes,'complete_mask_runtime',modes.lidar_mask&modes.radar_mask);
else
modes = setfield(modes,'complete_mask',struct('bit',1,'description',['data is good.  and of bits 1-9']));
modes = setfield(modes,'lidar_ok_mask',struct('bit',2,'description',['lidar data is present']));
modes = setfield(modes,'lock_quality_mask',struct('bit',3,'description',['laser is locked to iodine filter wavelength']));
modes = setfield(modes,'seed_quality_mask',struct('bit',4,'description',['laser wavelength is locked to seed laser']));
modes = setfield(modes,'mol_count_snr_mask',struct('bit',5,'description',['molecular signal/photon counting error in molecular signal is above specified threshhold']));
modes = setfield(modes,'backscat_snr_mask',struct('bit',6,'description',['backscatter cross-section/photon counting error in backscatter cross-section is above specified threshhold']));
modes = setfield(modes,'mol_lost_mask',struct('bit',7,'description',['number of molecular photon counts is above specified threshhold']));
modes = setfield(modes,'min_backscat_mask',struct('bit',8,'description',['lidar backscatter cross-section is above specified threshhold']));
modes = setfield(modes,'radar_backscat_mask',struct('bit',9,'description',['radar backscatter cross-section is above specified threshhold']));
modes = setfield(modes,'radar_ok_mask',struct('bit',10,'description',['radar data is present']));
modes = setfield(modes,'aeri_ok_mask',struct('bit',11,'description',['aeri data is present']));
modes = setfield(modes,'aeri_qc_mask',struct('bit',12,'description',['aeri data has passed a quality check']));
modes = setfield(modes,'lidar_mask',struct('operation','AND','operands',[],'dependencies',[],'description',['all lidar-realated quality checks pass']));
modes.lidar_mask.operands={...
	'lidar_ok_mask',...
	'lock_quality_mask',...
	'seed_quality_mask',...
	'mol_count_snr_mask',...
	'backscat_snr_mask',...
	'mol_lost_mask',...
	'min_backscat_mask'};
modes.lidar_mask.dependencies={...
	'backscat_snr_mask',...
	'lidar_ok_mask',...
	'lock_quality_mask',...
	'min_backscat_mask',...
	'mol_count_snr_mask',...
	'mol_lost_mask',...
	'seed_quality_mask'};
modes = setfield(modes,'od_mask',struct('operation','AND','operands',[],'dependencies',[],'description',['all optical depth-related quality checks pass']));
modes.od_mask.operands={...
	'lidar_ok_mask',...
	'lock_quality_mask',...
	'seed_quality_mask'};
modes.od_mask.dependencies={...
	'lidar_ok_mask',...
	'lock_quality_mask',...
	'seed_quality_mask'};
modes = setfield(modes,'radar_mask',struct('operation','AND','operands',[],'dependencies',[],'description',['all radar-related quality checks pass']));
modes.radar_mask.operands={...
	'radar_backscat_mask',...
	'radar_ok_mask'};
modes.radar_mask.dependencies={...
	'radar_backscat_mask',...
	'radar_ok_mask'};
modes = setfield(modes,'backscat_mask',struct('operation','AND','operands',[],'dependencies',[],'description',['backscatter signal present']));
modes.backscat_mask.operands={...
	'lidar_ok_mask',...
	'radar_ok_mask'};
modes.backscat_mask.dependencies={...
	'lidar_ok_mask',...
	'radar_ok_mask'};
modes = setfield(modes,'beta_a_mask',struct('operation','AND','operands',[],'dependencies',[],'description',['beta_a backscatter mask used in make_data_quality_masks']));
modes.beta_a_mask.operands={...
	'lock_quality_mask',...
	'seed_quality_mask',...
	'mol_count_snr_mask',...
	'backscat_snr_mask',...
	'mol_lost_mask',...
	'min_backscat_mask'};
modes.beta_a_mask.dependencies={...
	'backscat_snr_mask',...
	'lock_quality_mask',...
	'min_backscat_mask',...
	'mol_count_snr_mask',...
	'mol_lost_mask',...
	'seed_quality_mask'};
modes = setfield(modes,'complete_mask_runtime',struct('operation','AND','operands',[],'dependencies',[],'description',['runtime copy of complete_mask']));
modes.complete_mask_runtime.operands={...
	'lidar_mask',...
	'radar_mask'};
modes.complete_mask_runtime.dependencies={...
	'backscat_snr_mask',...
	'lidar_ok_mask',...
	'lock_quality_mask',...
	'min_backscat_mask',...
	'mol_count_snr_mask',...
	'mol_lost_mask',...
	'radar_backscat_mask',...
	'radar_ok_mask',...
	'seed_quality_mask'};
end