% $Id: paeri_pcfilter.m,v 1.1 2012/10/06 19:55:46 dataman Exp $
function [mean_rad,npcs] = paeri_pcfilter(wnum1,mean_rad,wnum1s,SkyNEN)
%
% function [mean_rad,npcs] = paeri_pcfilter(wnum1,mean_rad,wnum1s,SkyNEN);
%
%    ....This version of paeri_pcfilter.m uses the method of Turner et al,
%    2006: Noise reduction of Atmospheric Emitted Radiance Interferometer
%    (AERI) observations using Principal Component Analysis, J. Ocean.
%    Atmos. Tech, 23, 1223-1238.
%
%   ....This is, in turn, based on: Antonelli et al, 2004: 
%    A principal component noise filter for high spectral resolution
%    infrared measurements, J. Geophys. Res, 109, D23102, 
%    doi:10.1029/2004JD004862.
%
%
%    Input:
%    ------
%    wnum1    - Wavenumbers corresponding to PAERI mean_rad spectra
%    mean_rad - Mean radiances from PAERI
%    wnum1s   - Wavenumbers corresponding to PAERI SkyNEN spectra
%    SkyNEN   - Noise radiance spectra from PAERI
%
%    Output:
%    -------
%    mean_rad - Mean radiances with noise removed by PCA filtering
%               (NOTE that the input variable is written over!)
%    npcs     - Number of eigenvectors used for PC filtering;
%               this is an important parameter related to how good
%               the training set is for the filter.
%
%  Optimized for computational speed by Penny M. Rowe, 23 May 2009.  
%  See initials within for changes

% Interpolate SkyNEN spectra to full resolution of mean_rad data.
SkyNENi = interp1(wnum1s,SkyNEN',wnum1)';

[t,n] = size(mean_rad);

% STEP 1
%   Normalize the observed spectra by dividing by the estimated noise
%   equivalent spectral radiance (NESR).
%  !!!  Need to eventually be divided through by the noise spectrum
%  generated by the imaginary part of the calibrated radiance. 
fprintf('Normalize the spectra by SkyNEN...\n')
X           = mean_rad ./ SkyNENi;

fprintf('Generate the covariance matrix...\n');
c           = cov( X );

fprintf('Derive eigenvectors and eigenvalues...\n');
[U,D]     = svd( c );  % We don't need "V" (PMR)

% STEP 4
%   Determine the optimal number of eigenvectors to use (using the "factor
%   indicator function IND from Turner et al (2006).
%   The loop is over wavenumber (n) so this shouldn't take too long, but I
%   didn't check that (PMR)
fprintf('Determine optimal number of eigenvectors...\n');
l       = diag(D);
%l0      = flipud(cumsum(l));
%REk     = sqrt( l0(2:n) ./ (t.*(n-(1:(n-1))))' );
% pre-allocate lo for memory (PMR)
lo = zeros(1,n-1);
for k = 1:n-1
    lo(k) = sum(l(k+1:n));
end
REk     = sqrt( lo ./ (t.*(n-(1:(n-1)))) );
IND     = REk ./ (n-(1:(n-1))).^2;
npcs    = find(min(IND) == IND)

clear D c

% STEP 5
%   Project each spectrum onto the vector space spanned by eigenvectors.
%
%   As a loop, this step takes a very long time (PMR)
%sprintf('Project spectra...')
%coefs   = zeros(npcs,t);
%M       = mean( X );
%datestr(now)
%for k = 1:t
%    coef = ( X(k,:) - M ) * U(:,1:npcs);
%    coefs(:,k) = coef';
%end
%datestr(now)
%
% Instead, Vectorize for speed (PMR)
% The two methods differ by less than +/- 10^-11
M     = mean( X );
coefs = (X - ones(t,1)*M) * U(:,1:npcs);
coefs = coefs';


% STEP 6
%   Re-construct the data using the projection coefficients
fprintf('Re-construct spectra...\n');
% As commented out, the code is very slow (PMR)
% x = zeros(t,n);
% datestr(now)
% for k = 1:t
%     spectrum = U(:,1:npcs) * coefs(:,k) + M';
%     x(k,:) = spectrum;
% end
% datestr(now)
% 
% Again, instead vectorize for speed (PMR)
% The two methods differ by less than +/-1.5 x 10^-12
x = U(:,1:npcs)*coefs + M'*ones(1,t) ;


% STEP 7
%   Multiply each spectrum by the same noise spectrum used in Step 1
mean_rad = x' .* SkyNENi;

return

